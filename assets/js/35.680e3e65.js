(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{364:function(t,_,a){"use strict";a.r(_);var v=a(8),r=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[_("strong",[t._v("1.整数类型")])]),t._v(" "),_("h3",{attrs:{id:"_1-1-tinyint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-tinyint"}},[t._v("#")]),t._v(" 1.1 tinyint")]),t._v(" "),_("p",[t._v("tinyint 为"),_("strong",[t._v("小整数类型")]),t._v("，存储空间为1个字节（8位），有符号范围-128 ~ 127，无符号范围 0 ~ 255,此类型通常在数据库中表示类型的字段，如某一字段 type 表示学科,其中 “type=1” 表示语文，“type=2” 表示数学, “type=3” 表示英语，此时 type 字段即可使用 tinyint 这种存储空间比较小的类型。")]),t._v(" "),_("h3",{attrs:{id:"_1-2-smallint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-smallint"}},[t._v("#")]),t._v(" 1.2 smallint")]),t._v(" "),_("p",[t._v("smallint 为"),_("strong",[t._v("小整数类型")]),t._v("，存储空间2个字节(16位),有符号范围 -32768 ~ 32767，无符号范围 0 ~ 65535，当遇到最大值不超过 65535 的整数类型字段时，可使用无符号 smallint 类型。")]),t._v(" "),_("h3",{attrs:{id:"_1-3-mediumint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-mediumint"}},[t._v("#")]),t._v(" 1.3 mediumint")]),t._v(" "),_("p",[t._v("mediumint 为"),_("strong",[t._v("中整数类型")]),t._v("，存储空间3个字节（24位），有符号范围 -8388608 ~ 8388607，符号范围 0 ~ 16777215，当遇到最大值不超过 16777215 的整数类型字段时，可使用无符号 mediumint 类型。")]),t._v(" "),_("h3",{attrs:{id:"_1-4-int"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-int"}},[t._v("#")]),t._v(" 1.4 int")]),t._v(" "),_("p",[t._v("int 为"),_("strong",[t._v("整数类型")]),t._v("，存储空间 4 个字节 ( 32位 )，有符号范围 -2147483648 ~ 2147483647，无符号范围 0 ~ 49294967295，当遇到最大值不超过 49294967295 的整数类型字段时，可使用无符号 int 类型，通常自增主键 id 使用 int 类型。")]),t._v(" "),_("h3",{attrs:{id:"_1-5-bigint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-bigint"}},[t._v("#")]),t._v(" 1.5 bigint")]),t._v(" "),_("p",[t._v("bigint 为"),_("strong",[t._v("大整数类型")]),t._v("，存储空间8个字节(64位)，有符号范围 -9223372036854775808 ~ 9223372036854775807，无符号范围 0 ~ 18446744073709551615，当遇到最大值不超过 18446744073709551615 的整数类型字段时，可使用无符号 bigint 类型，通常自增主键 id 使用 int 无法满足时，可以使用 bigint 类型。")]),t._v(" "),_("p",[_("strong",[t._v("2.浮点类型")])]),t._v(" "),_("h3",{attrs:{id:"_2-1-float"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-float"}},[t._v("#")]),t._v(" 2.1 float")]),t._v(" "),_("p",[t._v("float 为"),_("strong",[t._v("单精度浮点类型")]),t._v("，存储空间 4 个字节，支使用标准的浮点运算进行近似计算，若想知道浮点运算是怎么计算的，则需要研究操作系统的浮点数方式，通常对小数精度要求不那么高的字段可使用 float 类型。")]),t._v(" "),_("h3",{attrs:{id:"_2-2-double"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-double"}},[t._v("#")]),t._v(" 2.2 double")]),t._v(" "),_("p",[t._v("double 为"),_("strong",[t._v("双精度浮点类型")]),t._v("，存储空间 8个字节，相比float 有更高精度和更大的范围，通常对小数精度要求不那么高，但比 float 要求更高的字段可使用 double 类型。")]),t._v(" "),_("h3",{attrs:{id:"_2-3-decimal"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-decimal"}},[t._v("#")]),t._v(" 2.3 decimal")]),t._v(" "),_("p",[t._v("decimal 类型"),_("strong",[t._v("用于存储精确的小数")]),t._v("，若使用 float 类型来取代一些需要精确小数点类型的字段时，大的数据量会导致数据错误，比如金额,若使用 float 类型，可能会丢失精度，此时对于金额这样对精度要求很高的字段来说，可以选择使用 decimal 类型。")]),t._v(" "),_("p",[_("strong",[t._v("3.日期和时间类型")])]),t._v(" "),_("h3",{attrs:{id:"_3-1-date"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-date"}},[t._v("#")]),t._v(" 3.1 date")]),t._v(" "),_("p",[t._v("date 类型为"),_("strong",[t._v("日期类型")]),t._v("，存储空间 3个字节，格式为 “YYYY-MM-DD”，例如 “2020-03-16”,日期的范围 “1000-01-01 ~ 9999-12-31”，通常只想用来存储如 “2020-02-02” 这种格式的日期字段时，可以选择使用 date 类型。")]),t._v(" "),_("h3",{attrs:{id:"_3-2-time"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-time"}},[t._v("#")]),t._v(" 3.2 time")]),t._v(" "),_("p",[t._v("time 类型为"),_("strong",[t._v("时间类型")]),t._v("，存储空间 3 ~ 6个字节，格式为 “HH::MM:SS[.微秒]” ，例如 “04:31:22.33”，范围 “-838:59:59 ~ 838:59:59”，通常只想用来存储如 “04:31:22.33” 这种格式的时间字段时，可以选择使用 time 类型。")]),t._v(" "),_("h3",{attrs:{id:"_3-3-year"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-year"}},[t._v("#")]),t._v(" 3.3 year")]),t._v(" "),_("p",[t._v("year 类型为"),_("strong",[t._v("日期类型")]),t._v("，存储空间 1 个字节 ，例如 “2020”，范围 “1901 ~ 2155”，通常只想用来存储如 “2020” 这种格式的日期字段时，可以选择使用 year 类型。")]),t._v(" "),_("h3",{attrs:{id:"_3-4-datetime"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-datetime"}},[t._v("#")]),t._v(" 3.4 datetime")]),t._v(" "),_("p",[t._v("datetime 类型为"),_("strong",[t._v("精确时间的日期类型")]),t._v("，存储空间为 5 ~ 8 个字节，格式为 “YYYY-MM-DD HH:MM:SS[.微秒值]”，例如 “2020-02-02 02:02:02.02”，范围 “1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 UTC”，通常只想用来存储如 “2020-02-02 02:02:02.02” 这种格式的日期字段时，可以选择使用 datetime 类型。")]),t._v(" "),_("h3",{attrs:{id:"_3-5-timestamp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-timestamp"}},[t._v("#")]),t._v(" 3.5 timestamp")]),t._v(" "),_("p",[t._v("timestamp 类型保存了"),_("strong",[t._v("从1970年01月01日午夜以来的秒数")]),t._v("，它和 "),_("strong",[t._v("UNIX 时间戳")]),t._v("相同，存储空间 4 ~ 7 个字节，范围 “1970-01-01 00:00：00 ~ 2038-01-19 03:14:07 UTC”，timestamp 显示的值依赖于时区，和 datetime 相比，前者提供的值与时区有关系，后者则保留文本表示的日期和时间。")]),t._v(" "),_("p",[_("strong",[t._v("4.字符串类型")])]),t._v(" "),_("h3",{attrs:{id:"_4-1-char"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-char"}},[t._v("#")]),t._v(" 4.1 char")]),t._v(" "),_("p",[t._v("char 类型为"),_("strong",[t._v("定长字符串类型")]),t._v("，适合存储很短的字符串，或者所有值都接近同一个长度，例如存储密码 md5 值，因为它是一个定长的值，对于经常变更的数据，char 比 varchar 更好，因为定长的 char 不容易产生碎片。")]),t._v(" "),_("h3",{attrs:{id:"_4-2-varchar"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-varchar"}},[t._v("#")]),t._v(" 4.2 varchar")]),t._v(" "),_("p",[t._v("varchar 类型用于存储"),_("strong",[t._v("可变长度字符串")]),t._v("，是最常见的字符串数据类型，对于短长度的字符串，它比定长的更为节省空间，varchar 节省空间对性能有帮助，varchar 类型的字符串有如下特点 :")]),t._v(" "),_("ul",[_("li",[t._v("字符串列的最大长度比平均长度大；")]),t._v(" "),_("li",[t._v("列的更新少，碎片问题较小；")]),t._v(" "),_("li",[t._v("使用了如 “UTF-8” 字符集，每个字符都使用不同的字节数来存储。")])]),t._v(" "),_("h3",{attrs:{id:"_4-3-text"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-text"}},[t._v("#")]),t._v(" 4.3 text")]),t._v(" "),_("p",[t._v("text 数据类型家族包括 : "),_("strong",[t._v("tinytext")]),t._v("、"),_("strong",[t._v("text")]),t._v("、"),_("strong",[t._v("mediumtext")]),t._v("、"),_("strong",[t._v("longtext")]),t._v("。MySQL 把每个 text 值当做一个独立的对象处理。若 text 家族的值太大时，InnoDB 存储引擎会额外使用存储区域来进行存储，通常存储文章这样比较长的内容字段时，可选择 text 家族类型。")]),t._v(" "),_("p",[_("strong",[t._v("5.枚举值类型")])]),t._v(" "),_("h3",{attrs:{id:"_5-1-enum"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-enum"}},[t._v("#")]),t._v(" 5.1 enum")]),t._v(" "),_("p",[t._v("enum 类型为"),_("strong",[t._v("枚举值类型")]),t._v("，有时可以使用枚举值替代字符串，枚举列可以把一些不重复的字符串存储为一个预定义的集合。MySQL 在存储枚举时非常紧凑，会根据列表值的数量压缩到 1 ~ 2 个字节，例如 ENUM （‘黄色’，‘黑色’，‘蓝色’，‘紫色’），枚举值类型字段的需求也可以使用 tinyint 类型来替代。")]),t._v(" "),_("p",[_("strong",[t._v("6")]),t._v("**.二进****制类型**")]),t._v(" "),_("h3",{attrs:{id:"_6-1-blob"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-blob"}},[t._v("#")]),t._v(" 6.1 blob")]),t._v(" "),_("p",[t._v("blob 数据类型家族包括 ："),_("strong",[t._v("tinybob")]),t._v("、"),_("strong",[t._v("blob")]),t._v("、"),_("strong",[t._v("mediumblob")]),t._v("、"),_("strong",[t._v("longblob")]),t._v("。和 text 家族一样，MySQL 把每个 text 值当做一个独立的对象处理。若 blob 家族的值太大时，InnoDB 存储引擎会额外使用存储区域来进行存储，blob 类型存储的是二进制数据,没有排序规则或字符集。")])])}),[],!1,null,null,null);_.default=r.exports}}]);